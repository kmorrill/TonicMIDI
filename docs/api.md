<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## LFO

src/lfo.js

A Low-Frequency Oscillator (LFO) generates wave values (sine, triangle, etc.)
at a given `frequency` and `amplitude`, optionally offset, and can map the
resulting wave to a MIDI CC range (e.g., 0–127).

**Typical Usage**:

```js
import { LFO } from "op-xy-live";

// Create a basic LFO
const myLfo = new LFO({
  frequency: 1.5,         // cycles per second (if you treat deltaTime as seconds)
  amplitude: 1.0,         // wave amplitude
  offset: 0.0,            // shifts the output value up/down
  shape: "sine",          // wave shape
  targetParam: "filterCutoff", // if integrated with a deviceDefinition mapping
  minCcValue: 30,         // wave minimum maps to CC=30
  maxCcValue: 100,        // wave maximum maps to CC=100
});

// Each update cycle (for example, each 1/60 second or each audio frame):
const deltaTime = 1/60;
const value = myLfo.update(deltaTime);
// 'value' is now the wave output (already mapped if targetParam is set).
```

### Parameters

*   `$0` **[Object][64]**  (optional, default `{}`)

    *   `$0.frequency`   (optional, default `1.0`)
    *   `$0.amplitude`   (optional, default `1.0`)
    *   `$0.offset`   (optional, default `0.0`)
    *   `$0.phase`   (optional, default `0.0`)
    *   `$0.shape`   (optional, default `"sine"`)
    *   `$0.useRadians`   (optional, default `true`)
    *   `$0.targetParam`   (optional, default `null`)
    *   `$0.minCcValue`   (optional, default `0`)
    *   `$0.maxCcValue`   (optional, default `127`)

### reset

Reset the oscillator's phase (and clears any memory of absolute time).

#### Parameters

*   `phase` **[number][65]** If `useRadians=true`, a value in \[0..2π).
    If `useRadians=false`, a value in \[0..1). (optional, default `0`)

## EnergyManager

src/energy-manager.js

The EnergyManager is an optional high-level orchestrator that adjusts
LiveLoops in real-time to reflect changes in "energy," such as hype or tension.
It does not handle transport or MIDI directly—only manipulates loops' patterns,
LFO parameters, muting/unmuting, etc.

### Example Usage

```js
import { EnergyManager } from "op-xy-live";

// Hypothetical loops:
//   drumLoop, bassLoop, melodyLoop
// These loops might have methods like setPattern, setMuted, etc.

// Optional chord and rhythm managers:
//   chordManager (for harmonic context),
//   rhythmManager (for subdivisions & accent patterns),
//   OR a globalContext holding both.

const manager = new EnergyManager({
  liveLoops: [drumLoop, bassLoop, melodyLoop],
  chordManager,
  rhythmManager
});

// Increase activity across loops ("full"), e.g. unmute, busier patterns
manager.setHypeLevel("full");

// Increase harmonic dissonance or remove root in bass for tension
manager.setTensionLevel("high");
```

### Parameters

*   `$0` **[Object][64]**  (optional, default `{}`)

    *   `$0.liveLoops`   (optional, default `[]`)
    *   `$0.chordManager`   (optional, default `null`)
    *   `$0.rhythmManager`   (optional, default `null`)
    *   `$0.globalContext`   (optional, default `null`)

### setHypeLevel

Sets the "hype" level (e.g., "low", "medium", "full") across all managed LiveLoops.
Use this to dynamically scale the energy or busyness of your arrangement.

Common behaviors might include:

*   "low": Mute certain parts or use simpler patterns
*   "medium": Partially active patterns
*   "full": Unmute everything, busier rhythms, stronger LFOs, etc.

If a globalContext or rhythmManager was provided, this method can also
adjust subdivisions accordingly (e.g. halfTime, normal, doubleTime).

#### Parameters

*   `level` **[string][66]** A label for the desired energy state (e.g. "low", "medium", "full").

### setTensionLevel

Sets the "tension" level (e.g. "none", "low", "mid", "high") across
all managed LiveLoops and optionally updates chord voicings or
omits fundamental notes for dissonance.

Examples:

*   "none": Very stable, e.g. close-voiced triads
*   "low": Slight added color tones
*   "mid": 7ths or 9ths for moderate tension
*   "high": Dissonant intervals, omitted fundamentals, etc.

#### Parameters

*   `level` **[string][66]** The desired tension level ("none", "low", "mid", "high").

### addLiveLoop

Adds a LiveLoop instance so that it can be controlled by this EnergyManager.

#### Parameters

*   `loop` **[object][64]** The LiveLoop instance to add.

### removeLiveLoop

Removes a previously added LiveLoop from EnergyManager control.

#### Parameters

*   `loop` **[object][64]** The LiveLoop instance to remove.

### setArrangementStyle

Sets a broad "arrangement style" that can be used to make coarse changes
to LiveLoops. This might force wide chord voicings, bigger reverb sends,
or drastically different patterns. The exact implementation is up to you.

#### Parameters

*   `style` **[string][66]** A label for the arrangement style (e.g. "wide", "minimal", etc.).

### setChordProgression

Updates the ChordManager (either directly or via globalContext) to set
a new chord progression. Any loops that depend on chordManager data
should adapt automatically on their next cycle.

#### Parameters

*   `progression` **[Array][67]** An array of chord objects (e.g. \[{ root: "C", type: "maj7" }, ...]).

## SyncopatedBass

**Extends BasePattern**

A Pattern class that generates a syncopated bass line based on:

1.  A preset "rhythm feel" (`funk`, `latin`, or `reggae`)
2.  Chord information from a `chordManager`
3.  Optional velocity shaping via a `rhythmManager`

The result is a "bassy" sequence that responds to chord changes and varies
its velocity on downbeats, offbeats, etc., for a more musical feel.

### Example Usage

```js
import { SyncopatedBass } from "op-xy-live/patterns/syncopated-bass.js";

// Suppose you have a chordManager that provides chords at each step.
const chordManager = new ChordManager({ ... });

// Create a syncopated bass pattern with "funk" style
const bassPattern = new SyncopatedBass({
  length: 16,
  octave: 2,
  probabilities: { root: 60, fifth: 30, third: 10 },
  rhythmPreset: "funk"
});

// In a LiveLoop:
const loop = new LiveLoop(midiBus, {
  pattern: bassPattern,
  context: { chordManager },
  midiChannel: 2,
  name: "Funky Bass"
});
```

### Parameters

*   `$0` **[Object][64]**  (optional, default `{}`)

    *   `$0.length`   (optional, default `16`)
    *   `$0.octave`   (optional, default `2`)
    *   `$0.probabilities`   (optional, default `{root:60,fifth:30,third:10}`)
    *   `$0.rhythmPreset`   (optional, default `"funk"`)
    *   `$0.probabilityToAdvance`   (optional, default `50`)
    *   `$0.restProbability`   (optional, default `30`)

## ContourMelodyOptions

Type: [Object][64]

### Properties

*   `contour` **[Array][67]<[number][65]>?** An array of integers representing "chord-tone index offsets" or steps in chord-tone space.
    Example: \[0, 1, 2, 1, -1]. Index 0 = chord root. Index 1 = next chord tone, etc.
    If chord.notes = \["C4", "E4", "G4", "B4"], index 1 might be "E4".
    Negative indices move backward in chord.notes (e.g., -1 picks the chord tone before the current one).
    We wrap or clamp if we go out of range.
*   `length` **[number][65]?** The number of steps before the pattern conceptually loops.
*   `allowRests` **[boolean][68]?** If true, you can randomly skip steps or rest. Implementation is optional.
*   `restProbability` **[number][65]?** Probability in percent (0..100) of generating a rest on any given step (only if allowRests=true).
*   `spiceProbability` **[number][65]?** Probability in percent (0..100) that we deviate from the pure chord tone
    to an approach/dissonance note. Higher tension might also increase this.
*   `randomFn` **[function][69]?** A custom random function for deterministic output in tests.

## DrumPattern

**Extends BasePattern**

DrumPattern is a Pattern class that automatically generates "low", "medium",
and "high" intensity versions of a specified drum pattern. By default, it
uses the "medium" version, but it can adapt to "low" or "high" when
orchestrated by an EnergyManager (or via a manual method call).

### Example Usage

```js
import { DrumPattern } from "op-xy-live/patterns/drum-pattern.js";

// The pattern is an object where each key is a "drum part" (e.g. "kick", "snare"),
// and each value is an array of 0/1 indicating hits. Each array should have
// 'patternLength' steps. (1 = hit, 0 = no hit)
const mediumDrums = {
  kick:  [1,0,0,0,1,0,0,0, 1,0,0,0,1,0,0,0],
  snare: [0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1],
  hat:   [1,1,0,1,1,1,0,1, 1,1,0,1,1,1,0,1]
};

// drumMap optionally translates part names to MIDI note names (or any note naming system).
// If not provided, the code will fall back to "C3" for unspecified drums.
const drumMap = {
  kick: "C2",
  snare: "D2",
  hat: "F#2"
};

// Create a DrumPattern that has "low", "medium", and "high" variants
// automatically derived from 'mediumDrums'.
const drumPattern = new DrumPattern({
  mediumPattern: mediumDrums,
  drumMap,
  patternLength: 16
});
```

### Parameters

*   `$0` **[Object][64]**  (optional, default `{}`)

    *   `$0.mediumPattern` &#x20;
    *   `$0.drumMap`   (optional, default `{}`)
    *   `$0.patternLength`   (optional, default `16`)

## ExplicitNotePattern

**Extends BasePattern**

### Parameters

*   `notesArray` &#x20;

## LiveLoop

src/live-loop.js

A LiveLoop class manages the playback logic for a single musical part or track.
It holds:

*   A Pattern (implementing `getNotes(stepIndex, context)` and `getLength()`)
*   An array of LFOs for parameter modulation
*   An internal list of active notes, so it can schedule `noteOff` events
    based on duration.

This class does NOT directly start or stop the transport; it relies on an
external TransportManager to call `tick()` on every step, and optionally
`updateLFOsOnly()` on high-resolution pulses. In typical usage, you won't
call these methods yourself; the TransportManager handles it.

### Example Usage

```js
import { LiveLoop, ExplicitNotePattern, LFO } from "op-xy-live";
import { MidiBus } from "op-xy-live";  // or a shared instance

// 1) Create a MIDI bus
const midiBus = new MidiBus();

// 2) Define a simple pattern (e.g., a short 4-step melodic line)
const myPattern = new ExplicitNotePattern([
  "C4", "E4", "G4", "B4"
]);

// 3) (Optional) Create an LFO that modulates filterCutoff
const myLFO = new LFO({ targetParam: "filterCutoff", frequency: 0.5 });

// 4) Create a LiveLoop that uses the pattern and LFO
const myLoop = new LiveLoop(midiBus, {
  pattern: myPattern,
  midiChannel: 1,
  lfos: [myLFO],
  name: "Melody"
});

// 5) (Optional) Add it to a TransportManager that calls myLoop.tick() for us
// ...

// 6) Change the pattern or transpose in real time:
myLoop.setTranspose(2); // shift up by 2 semitones
myLoop.setPattern(someOtherPattern, false); // queue new pattern for next cycle
```

### Parameters

*   `midiBus` &#x20;
*   `$1` **[Object][64]**  (optional, default `{}`)

    *   `$1.pattern` &#x20;
    *   `$1.lfos`   (optional, default `[]`)
    *   `$1.midiChannel`   (optional, default `1`)
    *   `$1.context`   (optional, default `{}`)
    *   `$1.globalContext`   (optional, default `null`)
    *   `$1.name`   (optional, default `""`)
    *   `$1.muted`   (optional, default `false`)
    *   `$1.transpose`   (optional, default `0`)
    *   `$1.deviceDefinition`   (optional, default `null`)
    *   `$1.deviceManager`   (optional, default `null`)
    *   `$1.midiOutputId`   (optional, default `null`)
    *   `$1.cycles`   (optional, default `null`)

### chainLiveLoop

chainLiveLoop(params) - Add another sub-loop to the chain.

Example:

```js
new LiveLoop(midiBus, { pattern: patA, cycles: 2 })
  .chainLiveLoop({ pattern: patB, cycles: 4 })
  .chainLiveLoop({ pattern: patC, cycles: 8 })
  .onChainComplete(() => console.log("All done"));
```

#### Parameters

*   `params` **[object][64]**  (optional, default `{}`)

    *   `params.pattern` **[object][64]**&#x20;
    *   `params.cycles` **[number][65]**  (optional, default `1`)
    *   `params.midiChannel` **[number][65]?**&#x20;

Returns **[LiveLoop][30]** this

### onChainComplete

onChainComplete(callback) - Called once the final chain item finishes.
If no chain is used, this never fires.

#### Parameters

*   `callback` **[function][69]**&#x20;

Returns **[LiveLoop][30]** this

### setPattern

Immediately replaces the current pattern or queues the change to occur
at the next pattern boundary (start of pattern).

#### Parameters

*   `newPattern` **[object][64]** The new pattern, which must implement `getNotes()` and `getLength()`.
*   `immediate` **[boolean][68]**  (optional, default `false`)

### addLFO

Add an LFO immediately (no enqueuing needed).

#### Parameters

*   `lfo` **[object][64]**&#x20;

### updateLFO

Update properties of an existing LFO. If `immediate=false`, the change
will be applied at the next pattern boundary, so you don't abruptly
alter its state mid-cycle.

#### Parameters

*   `index` **[number][65]**&#x20;
*   `newProps` **[object][64]**&#x20;
*   `immediate` **[boolean][68]**  (optional, default `false`)

### setContext

Sets or updates the local context. The pattern receives this context each
step in `getNotes(stepIndex, context)`, so you can store chord data,
user-defined flags, or anything else to influence note generation.

#### Parameters

*   `context` **[object][64]**&#x20;
*   `immediate` **[boolean][68]**  (optional, default `true`)

### setGlobalContext

Sets or updates the global context reference. Useful if your system
has a shared context with chordManager or rhythmManager that you
want to attach after constructing the loop.

#### Parameters

*   `globalContext` **[object][64]**&#x20;

### setMuted

Mutes or unmutes the loop. If muted, no noteOn events are sent,
though noteOff will still occur to end any sustained notes.

#### Parameters

*   `bool` **[boolean][68]**&#x20;

### setTranspose

Applies a semitone transposition to all played notes.

#### Parameters

*   `semitones` **[number][65]**&#x20;

### setName

Assign a descriptive or friendly name (e.g. "Bass", "Melody", "Drums").

#### Parameters

*   `name` **[string][66]**&#x20;

## createPhrasePattern

meta-phrase-pattern.js

Provides a function `createPhrasePattern` that combines any two existing patterns
(main vs. fill) into a single "meta pattern." By default, it repeats
4 bars of main + 1 bar of fill, but you can configure any ratio of main vs fill bars.

Usage:
import { createPhrasePattern } from './meta-phrase-pattern.js';
import { DrumPattern } from './patterns/drum-pattern.js'; // e.g.

const mainDrum = new DrumPattern(...);
const fillDrum = new DrumPattern(...);

const phrasedDrumPattern = createPhrasePattern(
mainDrum,
fillDrum,
{
barsOfMain: 4,
barsOfFill: 1,
barLengthInSteps: 16,
onPhraseStart: (phraseIndex) => console.log('New phrase started:', phraseIndex),
onPhraseEnd: (phraseIndex) => console.log('Phrase ended:', phraseIndex),
}
);

// Then in your LiveLoop:
const loop = new LiveLoop(midiBus, {
pattern: phrasedDrumPattern,
...
});

### Parameters

*   `mainPattern` &#x20;
*   `fillPattern` &#x20;
*   `$2` **[Object][64]**  (optional, default `{}`)

    *   `$2.barsOfMain`   (optional, default `4`)
    *   `$2.barsOfFill`   (optional, default `1`)
    *   `$2.barLengthInSteps`   (optional, default `16`)
    *   `$2.onPhraseStart`   (optional, default `null`)
    *   `$2.onPhraseEnd`   (optional, default `null`)

## createPhrasePattern

Wraps two existing patterns (main and fill) into a single meta-pattern
that alternates 4 bars of main and 1 bar of fill, repeating indefinitely.

You can pass ANY pattern object for mainPattern or fillPattern, as long as
it implements `getNotes(stepIndex, context)` and `getLength()`.

### Parameters

*   `mainPattern` **[object][64]** An existing pattern implementing {getNotes, getLength}
*   `fillPattern` **[object][64]** Another pattern, used for the "fill" measure
*   `options` **[PhrasePatternOptions][57]**  (optional, default `{}`)

    *   `options.barsOfMain`   (optional, default `4`)
    *   `options.barsOfFill`   (optional, default `1`)
    *   `options.barLengthInSteps`   (optional, default `16`)
    *   `options.onPhraseStart`   (optional, default `null`)
    *   `options.onPhraseEnd`   (optional, default `null`)

## PhrasePatternOptions

Type: [Object][64]

### Properties

*   `barsOfMain` **[number][65]?** Number of bars (measures) to use the mainPattern.
*   `barsOfFill` **[number][65]?** Number of bars (measures) to use the fillPattern.
*   `barLengthInSteps` **[number][65]?** How many steps in one bar. Typically 16 if you're doing 4/4 with each quarter = 4 steps.
*   `onPhraseStart` **[function][69]?** Callback when a phrase starts. (phraseIndex) => void
*   `onPhraseEnd` **[function][69]?** Callback when a phrase ends.   (phraseIndex) => void

## getNotes

Called each step by the LiveLoop. We must have a chord from chordManager, or we throw an error.
If we have a rhythmManager, we can do additional logic like skipping offbeats.
If tension is high, we might increase spice probability, etc.

### Parameters

*   `stepIndex` **[number][65]**&#x20;
*   `context` **[object][64]** Typically includes { chordManager, rhythmManager, energyState, ... } (optional, default `{}`)

Returns **[Array][67]<{note: [string][66], velocity: [number][65], durationSteps: [number][65]}>**&#x20;

## getLength

The pattern length in steps for looping or boundary logic.

Returns **[number][65]**&#x20;

## reset

Optional: If we want to reset the pattern’s internal index or other state.
Called, for example, when the transport restarts or user wants a fresh cycle.

## toConfig

Returns a config object describing this pattern’s settings (for debugging or serialization).

Returns **[Object][64]**&#x20;

