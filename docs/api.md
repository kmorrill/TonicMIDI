<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## LFO

src/lfo.js

A Low-Frequency Oscillator (LFO) generates wave values (sine, triangle, etc.)
at a given `frequency` and `amplitude`, optionally offset, and can map the
resulting wave to a MIDI CC range (e.g., 0–127).

**Typical Usage**:

```js
import { LFO } from "op-xy-live";

// Create a basic LFO
const myLfo = new LFO({
  frequency: 1.5,         // cycles per second (if you treat deltaTime as seconds)
  amplitude: 1.0,         // wave amplitude
  offset: 0.0,            // shifts the output value up/down
  shape: "sine",          // wave shape
  targetParam: "filterCutoff", // if integrated with a deviceDefinition mapping
  minCcValue: 30,         // wave minimum maps to CC=30
  maxCcValue: 100,        // wave maximum maps to CC=100
});

// Each update cycle (for example, each 1/60 second or each audio frame):
const deltaTime = 1/60;
const value = myLfo.update(deltaTime);
// 'value' is now the wave output (already mapped if targetParam is set).
```

### Parameters

*   `$0` **[Object][78]**  (optional, default `{}`)

    *   `$0.frequency`   (optional, default `1.0`)
    *   `$0.amplitude`   (optional, default `1.0`)
    *   `$0.offset`   (optional, default `0.0`)
    *   `$0.phase`   (optional, default `0.0`)
    *   `$0.shape`   (optional, default `"sine"`)
    *   `$0.useRadians`   (optional, default `true`)
    *   `$0.targetParam`   (optional, default `null`)
    *   `$0.minCcValue`   (optional, default `0`)
    *   `$0.maxCcValue`   (optional, default `127`)

### update

Advance the LFO by a given time increment.

**Typically called by your engine or loop** to move the oscillator forward in time.

#### Parameters

*   `deltaTime` **[number][79]** The time elapsed since the last LFO update. This could be in seconds (if
    frequency is cycles/second) or in beats (if frequency is cycles/beat).

Returns **[number][79]** The LFO's current output value, after updating its phase. If `targetParam`
is set, the value may already be mapped into a CC range (e.g. 0..127).

### updateContinuousTime

Update the LFO based on an absolute time, rather than an incremental delta.
This is **advanced usage** for scenarios where you want more precise control
in a timeline. The phase is derived from the difference between this call's
`absoluteTime` and the previous one.

#### Parameters

*   `absoluteTime` **[number][79]** The current time in the same units you treat `frequency` with (e.g. seconds).

Returns **[number][79]** The updated wave output (same range/logic as `update()`).

### reset

Reset the oscillator's phase (and clears any memory of absolute time).

#### Parameters

*   `phase` **[number][79]** If `useRadians=true`, a value in \[0..2π).
    If `useRadians=false`, a value in \[0..1). (optional, default `0`)

### setFrequency

#### Parameters

*   `freq` **[number][79]** New LFO frequency (cycles per time unit).

### getFrequency

Returns **[number][79]** The current LFO frequency.

### setAmplitude

#### Parameters

*   `amp` **[number][79]** New LFO amplitude.

### getAmplitude

Returns **[number][79]** The current LFO amplitude.

### setOffset

#### Parameters

*   `off` **[number][79]** New DC offset for the LFO wave.

### getOffset

Returns **[number][79]** The current LFO offset.

### setShape

#### Parameters

*   `shape` **[string][80]** New wave shape ("sine", "triangle", "square", etc.).

### getShape

Returns **[string][80]** The current wave shape.

### setPhase

#### Parameters

*   `p` **[number][79]** New phase (useRadians ? 0..2π : 0..1).

### getPhase

Returns **[number][79]** The current oscillator phase.

### setUseRadians

#### Parameters

*   `bool` **[boolean][81]** True if phase calculations are in radians, false if normalized 0..1.

### getUseRadians

Returns **[boolean][81]** Whether the LFO uses radians for phase.

### setTargetParam

#### Parameters

*   `param` **([string][80] | null)** If set, wave output maps to CC range for that param name.

### getTargetParam

Returns **([string][80] | null)** The parameter targeted by this LFO.

### setMinCcValue

#### Parameters

*   `value` **[number][79]** New minimum CC value for wave's lower bound.

### getMinCcValue

Returns **[number][79]** The min CC value used when targetParam is set.

### setMaxCcValue

#### Parameters

*   `value` **[number][79]** New maximum CC value for wave's upper bound.

### getMaxCcValue

Returns **[number][79]** The max CC value used when targetParam is set.

## EnergyManager

src/energy-manager.js

The EnergyManager is an optional high-level orchestrator that adjusts
LiveLoops in real-time to reflect changes in "energy," such as hype or tension.
It does not handle transport or MIDI directly—only manipulates loops' patterns,
LFO parameters, muting/unmuting, etc.

### Example Usage

```js
import { EnergyManager } from "op-xy-live";

// Hypothetical loops:
//   drumLoop, bassLoop, melodyLoop
// These loops might have methods like setPattern, setMuted, etc.

// Optional chord and rhythm managers:
//   chordManager (for harmonic context),
//   rhythmManager (for subdivisions & accent patterns),
//   OR a globalContext holding both.

const manager = new EnergyManager({
  liveLoops: [drumLoop, bassLoop, melodyLoop],
  chordManager,
  rhythmManager
});

// Increase activity across loops ("full"), e.g. unmute, busier patterns
manager.setHypeLevel("full");

// Increase harmonic dissonance or remove root in bass for tension
manager.setTensionLevel("high");
```

### Parameters

*   `$0` **[Object][78]**  (optional, default `{}`)

    *   `$0.liveLoops`   (optional, default `[]`)
    *   `$0.chordManager`   (optional, default `null`)
    *   `$0.rhythmManager`   (optional, default `null`)
    *   `$0.globalContext`   (optional, default `null`)

### setHypeLevel

Sets the "hype" level (e.g., "low", "medium", "full") across all managed LiveLoops.
Use this to dynamically scale the energy or busyness of your arrangement.

Common behaviors might include:

*   "low": Mute certain parts or use simpler patterns
*   "medium": Partially active patterns
*   "full": Unmute everything, busier rhythms, stronger LFOs, etc.

If a globalContext or rhythmManager was provided, this method can also
adjust subdivisions accordingly (e.g. halfTime, normal, doubleTime).

#### Parameters

*   `level` **[string][80]** A label for the desired energy state (e.g. "low", "medium", "full").

### setTensionLevel

Sets the "tension" level (e.g. "none", "low", "mid", "high") across
all managed LiveLoops and optionally updates chord voicings or
omits fundamental notes for dissonance.

Examples:

*   "none": Very stable, e.g. close-voiced triads
*   "low": Slight added color tones
*   "mid": 7ths or 9ths for moderate tension
*   "high": Dissonant intervals, omitted fundamentals, etc.

#### Parameters

*   `level` **[string][80]** The desired tension level ("none", "low", "mid", "high").

### addLiveLoop

Adds a LiveLoop instance so that it can be controlled by this EnergyManager.
Useful if new loops are created or loaded dynamically.

#### Parameters

*   `loop` **[object][78]** The LiveLoop instance to add.

### removeLiveLoop

Removes a previously added LiveLoop from EnergyManager control.

#### Parameters

*   `loop` **[object][78]** The LiveLoop instance to remove.

### setArrangementStyle

Sets a broad "arrangement style" that can be used to make coarse changes
to LiveLoops. This might force wide chord voicings, bigger reverb sends,
or drastically different patterns. The exact implementation is up to you.

#### Parameters

*   `style` **[string][80]** A label for the arrangement style (e.g. "wide", "minimal", etc.).

### setChordProgression

Updates the ChordManager (either directly or via globalContext) to set
a new chord progression. Any loops that depend on chordManager data
should adapt automatically on their next cycle.

#### Parameters

*   `progression` **[Array][82]** An array of chord objects (e.g. \[{ root: "C", type: "maj7" }, ...]).

## SyncopatedBass

**Extends AbstractPattern**

A Pattern class that generates a syncopated bass line based on:

1.  A preset "rhythm feel" (`funk`, `latin`, or `reggae`)
2.  Chord information from a `chordManager`
3.  Optional velocity shaping via a `rhythmManager`

The result is a "bassy" sequence that responds to chord changes and varies
its velocity on downbeats, offbeats, etc., for a more musical feel.

### Example Usage

```js
import { SyncopatedBass } from "op-xy-live/patterns/syncopated-bass.js";

// Suppose you have a chordManager that provides chords at each step.
const chordManager = new ChordManager({ ... });

// Create a syncopated bass pattern with "funk" style
const bassPattern = new SyncopatedBass({
  length: 16,
  octave: 2,
  probabilities: { root: 60, fifth: 30, third: 10 },
  rhythmPreset: "funk"
});

// In a LiveLoop:
const loop = new LiveLoop(midiBus, {
  pattern: bassPattern,
  context: { chordManager },
  midiChannel: 2,
  name: "Funky Bass"
});
```

### Parameters

*   `$0` **[Object][78]**  (optional, default `{}`)

    *   `$0.length`   (optional, default `16`)
    *   `$0.octave`   (optional, default `2`)
    *   `$0.probabilities`   (optional, default `{root:60,fifth:30,third:10}`)
    *   `$0.rhythmPreset`   (optional, default `"funk"`)
    *   `$0.probabilityToAdvance`   (optional, default `50`)
    *   `$0.restProbability`   (optional, default `30`)

## DrumPattern

**Extends AbstractPattern**

DrumPattern is a Pattern class that automatically generates "low", "medium",
and "high" intensity versions of a specified drum pattern. By default, it
uses the "medium" version, but it can adapt to "low" or "high" when
orchestrated by an EnergyManager (or via a manual method call).

### Example Usage

```js
import { DrumPattern } from "op-xy-live/patterns/drum-pattern.js";

// The pattern is an object where each key is a "drum part" (e.g. "kick", "snare"),
// and each value is an array of 0/1 indicating hits. Each array should have
// 'patternLength' steps. (1 = hit, 0 = no hit)
const mediumDrums = {
  kick:  [1,0,0,0,1,0,0,0, 1,0,0,0,1,0,0,0],
  snare: [0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1],
  hat:   [1,1,0,1,1,1,0,1, 1,1,0,1,1,1,0,1]
};

// drumMap optionally translates part names to MIDI note names (or any note naming system).
// If not provided, the code will fall back to "C3" for unspecified drums.
const drumMap = {
  kick: "C2",
  snare: "D2",
  hat: "F#2"
};

// Create a DrumPattern that has "low", "medium", and "high" variants
// automatically derived from 'mediumDrums'.
const drumPattern = new DrumPattern({
  mediumPattern: mediumDrums,
  drumMap,
  patternLength: 16
});
```

### Parameters

*   `$0` **[Object][78]**  (optional, default `{}`)

    *   `$0.mediumPattern` &#x20;
    *   `$0.drumMap`   (optional, default `{}`)
    *   `$0.patternLength`   (optional, default `16`)

## ExplicitNotePattern

**Extends AbstractPattern**

### Parameters

*   `notesArray` &#x20;

## LiveLoop

src/live-loop.js

A LiveLoop class manages the playback logic for a single musical part or track.
It holds:

*   A Pattern (implementing `getNotes(stepIndex, context)` and `getLength()`)
*   An array of LFOs for parameter modulation
*   An internal list of active notes, so it can schedule `noteOff` events
    based on duration.

This class does NOT directly start or stop the transport; it relies on an
external TransportManager to call `tick()` on every step, and optionally
`updateLFOsOnly()` on high-resolution pulses. In typical usage, you won't
call these methods yourself; the TransportManager handles it.

### Example Usage

```js
import { LiveLoop, ExplicitNotePattern, LFO } from "op-xy-live";
import { MidiBus } from "op-xy-live";  // or a shared instance

// 1) Create a MIDI bus
const midiBus = new MidiBus();

// 2) Define a simple pattern (e.g., a short 4-step melodic line)
const myPattern = new ExplicitNotePattern([
  "C4", "E4", "G4", "B4"
]);

// 3) (Optional) Create an LFO that modulates filterCutoff
const myLFO = new LFO({ targetParam: "filterCutoff", frequency: 0.5 });

// 4) Create a LiveLoop that uses the pattern and LFO
const myLoop = new LiveLoop(midiBus, {
  pattern: myPattern,
  midiChannel: 1,
  lfos: [myLFO],
  name: "Melody"
});

// 5) (Optional) Add it to a TransportManager that calls myLoop.tick() for us
// ...

// 6) Change the pattern or transpose in real time:
myLoop.setTranspose(2); // shift up by 2 semitones
myLoop.setPattern(someOtherPattern, false); // queue new pattern for next cycle
```

### Parameters

*   `midiBus` &#x20;
*   `$1` **[Object][78]**  (optional, default `{}`)

    *   `$1.pattern` &#x20;
    *   `$1.lfos`   (optional, default `[]`)
    *   `$1.midiChannel`   (optional, default `1`)
    *   `$1.context`   (optional, default `{}`)
    *   `$1.globalContext`   (optional, default `null`)
    *   `$1.name`   (optional, default `""`)
    *   `$1.muted`   (optional, default `false`)
    *   `$1.transpose`   (optional, default `0`)
    *   `$1.deviceDefinition`   (optional, default `null`)
    *   `$1.deviceManager`   (optional, default `null`)
    *   `$1.midiOutputId`   (optional, default `null`)

### setPattern

Immediately replaces the current pattern or queues the change to occur
at the next pattern boundary (start of pattern).

#### Parameters

*   `newPattern` **[object][78]** The new pattern, which must implement `getNotes()` and `getLength()`.
*   `immediate` **[boolean][81]** If true, replace the pattern right away; if false, wait until the next
    time `stepIndex` modulo pattern length = 0. (optional, default `false`)

### addLFO

Add an LFO immediately (no enqueuing needed).

#### Parameters

*   `lfo` **[object][78]** An LFO instance (e.g. new LFO({ ... }))

### updateLFO

Update properties of an existing LFO. If `immediate=false`, the change
will be applied at the next pattern boundary, so you don't abruptly
alter its state mid-cycle.

#### Parameters

*   `index` **[number][79]** The index of the LFO in the `lfos` array.
*   `newProps` **[object][78]** An object of updated properties, e.g. `{ frequency: 2.0 }`.
*   `immediate` **[boolean][81]** If true, apply changes now; otherwise, queue them. (optional, default `false`)

### setContext

Sets or updates the local context. The pattern receives this context each
step in `getNotes(stepIndex, context)`, so you can store chord data,
user-defined flags, or anything else to influence note generation.

#### Parameters

*   `context` **[object][78]** The new local context.
*   `immediate` **[boolean][81]** If true, apply immediately. If false, wait until the pattern boundary. (optional, default `true`)

### setGlobalContext

Sets or updates the global context reference. Useful if your system
has a shared context with chordManager or rhythmManager that you
want to attach after constructing the loop.

#### Parameters

*   `globalContext` **[object][78]** The new global context object.

### setMuted

Mutes or unmutes the loop. If muted, it won't send any `noteOn` events,
although it will still handle durations and eventually send `noteOff`.

#### Parameters

*   `bool` **[boolean][81]** If true, liveLoop is muted.

### setTranspose

Applies a semitone transposition to all played notes. Typically used by
an EnergyManager or tension mechanism to create pitch shifts. E.g. setTranspose(7)
might raise all notes by a perfect fifth for tension.

#### Parameters

*   `semitones` **[number][79]** Positive to shift up, negative to shift down.

### setName

Assign a descriptive or friendly name (e.g. "Bass", "Melody", "Drums").
This can be helpful for orchestration or debugging logs.

#### Parameters

*   `name` **[string][80]** The new name for this loop.

