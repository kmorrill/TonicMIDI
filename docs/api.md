<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## ChordManager

src/chord-manager.js

Revised so ONLY the authorized provider can set chords.

### authorizeProvider

Called typically by TransportManager or some setup code
to designate which pattern/loop is allowed to set chords.

#### Parameters

*   `providerId` **([string][141] | [number][142])**&#x20;

### setCurrentChord

Sets the current chord info for this step IF callerId
matches the authorized provider.

#### Parameters

*   `callerId` **([string][141] | [number][142])** The ID of the pattern/loop calling this.
*   `rootNote` **[string][141]** e.g. "C4" (if you have octaves),
    or "C" (if you prefer just letter names).
*   `chordNotes` **[Array][143]<[string][141]>** e.g. \["C4", "E4", "G4"] or empty if no chord. (optional, default `[]`)

### getCurrentRootNote

Returns the current root note name or null if none is set.

Returns **([string][141] | null)**&#x20;

### getCurrentChordNotes

Returns an array of chord note names for the current beat.

Returns **[Array][143]<[string][141]>**&#x20;

### clearChord

Clears the chord data (only the authorized provider can do so).

#### Parameters

*   `callerId` &#x20;

## EnergyManager

src/energy-manager.js

A hybrid approach:

*   The manager does some big-picture changes (e.g. unmuting loops, storing "doubleTime")
*   Patterns can read hype/tension from here, plus "currentSubdivision",
    and decide how to interpret that (like playing faster patterns).

### Parameters

*   `$0` **[Object][144]**  (optional, default `{}`)

    *   `$0.liveLoops`   (optional, default `[]`)
    *   `$0.globalContext`   (optional, default `null`)

### setHypeLevel

Sets the hype level ("low","medium","high", etc.),
does some big changes (unmute loops, etc.), and
sets `this.currentSubdivision` so patterns can see it and interpret double-time or half-time.

#### Parameters

*   `level` **[string][141]**&#x20;

### setTensionLevel

Sets the tension level. We do NOT push this to chordManager,
but store it for patterns to read if they want dissonance or omit fundamentals, etc.

#### Parameters

*   `level` **[string][141]**&#x20;

### setArrangementStyle

Sets a broad arrangement style label (e.g. "wide", "minimal"),
logs or manipulates loops if desired.

#### Parameters

*   `style` **[string][141]**&#x20;

### getHypeLevel

Getter for hype level

Returns **[string][141]**&#x20;

### getTensionLevel

Getter for tension level

Returns **[string][141]**&#x20;

### getArrangementStyle

Getter for arrangement style

Returns **([string][141] | null)**&#x20;

### getSubdivision

Getter for current subdivision (e.g. "normal","doubleTime","halfTime"),
which patterns can read if they want to interpret faster or slower patterns.

Returns **[string][141]**&#x20;

### addLiveLoop

Add a liveLoop after the manager is constructed

#### Parameters

*   `loop` **[object][144]**&#x20;

### removeLiveLoop

Remove a previously added liveLoop

#### Parameters

*   `loop` **[object][144]**&#x20;

## GlobalContext

### Parameters

*   `$0` **[Object][144]**  (optional, default `{}`)

    *   `$0.chordManager`   (optional, default `new ChordManager()`)
    *   `$0.rhythmManager`   (optional, default `new RhythmManager()`)
    *   `$0.energyManager`   (optional, default `null`)
    *   `$0.additionalContext`   (optional, default `{}`)

### setTensionLevel

Sets the global tension level and propagates it to the chord manager

#### Parameters

*   `level` **[string][141]** Tension level ("none", "low", "mid", "high")

### setHypeLevel

Sets the global hype level (energy or intensity)

#### Parameters

*   `level` **[string][141]** Hype level ("low", "medium", "high")

### getEnergyState

Gets the current energy state

Returns **[Object][144]** The current energy state (hype and tension levels)

### updateAdditionalContext

Updates or adds additional context data

#### Parameters

*   `newContext` **[Object][144]** New context data to merge with existing additionalContext

### createPatternContext

Creates a pattern-specific context that includes all global context plus
pattern-specific overrides

#### Parameters

*   `patternContext` **[Object][144]** Pattern-specific context that overrides global values (optional, default `{}`)

Returns **[Object][144]** Combined context with pattern-specific values taking precedence

## RhythmManager

src/rhythm-manager.js

A simplified RhythmManager that tracks:

*   The current subdivision ("normal", "doubleTime", "halfTime", etc.).
*   Basic step-per-beat and step-per-bar info.
*   Whether there's a kick on this beat (a single boolean).

Exactly one "kick provider" pattern sets `kickThisBeat` each step.
Other patterns can read it if they want to coordinate with the kick.

Now hardened so only the authorized kick provider can set the kick.

### Parameters

*   `$0` **[Object][144]**  (optional, default `{}`)

    *   `$0.stepsPerBar`   (optional, default `16`)
    *   `$0.stepsPerBeat`   (optional, default `4`)
    *   `$0.subdivision`   (optional, default `"normal"`)

### authorizeKickProvider

Authorizes a single pattern or loop ID to set the kick.

#### Parameters

*   `providerId` **([string][141] | [number][142])**&#x20;

### setKickOnThisBeat

Sets whether the kick is on for this beat/step,
but only if callerId matches the authorized provider.

#### Parameters

*   `callerId` **([string][141] | [number][142])** ID of the loop/pattern attempting to set the kick
*   `isOn` **[boolean][145]**&#x20;

### isKickOnThisBeat

Returns true if the kick is on for this beat.

Returns **[boolean][145]**&#x20;

### isDownbeat

Checks if the given step is the downbeat (stepIndex % stepsPerBar === 0).
e.g. in 16-step bars, step 0,16,32,... are downbeats.

#### Parameters

*   `stepIndex` **[number][142]**&#x20;

Returns **[boolean][145]**&#x20;

### isBeat

Checks if the given step is a quarter-note beat (stepIndex % stepsPerBeat === 0).

#### Parameters

*   `stepIndex` **[number][142]**&#x20;

Returns **[boolean][145]**&#x20;

### isOffbeat

Checks if the given step is an offbeat (e.g., stepIndex % stepsPerBeat === stepsPerOffbeat).
In default 4/4, that's stepIndex % 4 === 2 for offbeats.

#### Parameters

*   `stepIndex` **[number][142]**&#x20;

Returns **[boolean][145]**&#x20;

### getSubdivision

Returns a small integer describing the position in the subdivision:
0 => downbeat
1 => any other beat
2 => offbeat
3 => everything else

#### Parameters

*   `stepIndex` **[number][142]**&#x20;

Returns **[number][142]** 0..3

### getBeatNumber

Returns the beat number (1-based) within the bar.
For example, if stepsPerBeat=4, stepsPerBar=16,
stepIndex=0..3 => beat#1, stepIndex=4..7 => beat#2, etc.

#### Parameters

*   `stepIndex` **[number][142]**&#x20;

Returns **[number][142]**&#x20;

### setSubdivision

Allows external code (EnergyManager, etc.) to set the subdivision:
"normal", "doubleTime", or "halfTime". Then we recalc stepsPerBar/Beat.

#### Parameters

*   `subdivision` **[string][141]**&#x20;

### getAccentPattern

OPTIONAL: Returns an array of accent velocities for each step in the bar,
if you want to program dynamic accent patterns.

Returns **[Array][143]<[number][142]>** An array of length stepsPerBar with accent values

## SyncopatedBass

**Extends BasePattern**

SyncopatedBass

Creates a stable (non-changing) rhythmic pattern with the following user controls:

*   patternLength: total steps in the loop (16 or 32 typically)
*   genre: which base groove to seed (e.g. "funk","latin","house", etc.)
*   octave: the single octave in which to place notes (e.g. 2 => "C2")
*   density: 0..1 controlling how many total “events” are kept
*   randomFn: optional seeded random if you want deterministic results

On each step, we look up chord/hype/tension/beat managers to adapt pitch and velocity.
Some notes may last multiple steps (2..3).

We'll preserve multi-step durations from the seed. The "density" logic removes or adds
entire events (i.e., entire multi-step segments), without forcing them to become single-step hits.

### Parameters

*   `$0` **[Object][144]**  (optional, default `{}`)

    *   `$0.patternLength`   (optional, default `16`)
    *   `$0.genre`   (optional, default `"funk"`)
    *   `$0.octave`   (optional, default `2`)
    *   `$0.density`   (optional, default `0.5`)
    *   `$0.randomFn`   (optional, default `Math.random`)

### \_generatePattern

We define base seeds for multiple genres. Each is length=16, each element is either
0 (rest) or a positive integer meaning that many steps of a single note event.

### \_adaptSeedToLength

If user's patternLength != 16, replicate or slice the seed to match the length.
We keep the multi-step structure. For example, if patternLength=8, we take the first 8 steps.
If patternLength=32, we replicate the seed 2 times, etc.

#### Parameters

*   `seed` &#x20;
*   `length` &#x20;

### \_applyDensity

Removes or adds entire events to match an approximate target event count.
We do *not* forcibly break a "2" into two "1"s, nor do we unify single-step hits
into multi-step hits. We simply remove or replicate entire events if needed.

Steps:

1.  Identify the start indexes of each event. (An event starts at index i if pattern\[i] > 0.)
2.  Count how many events we have. Compare to target = density \* patternLength (rounded).
3.  If too many events, remove random ones until we reach target (cannot go below 1 or above length).
4.  If too few events, add random new events (with random durations 1..2 or something) until we approximate target.

#### Parameters

*   `array` &#x20;

### \_fillAllSteps

Called if density=1 => we want no rests. We'll fill all empty slots with new events,
but keep existing multi-step notes intact. If an event is 2 steps at index=0, that's fine.

#### Parameters

*   `array` &#x20;

### \_scanEvents

Helper that returns an array of { start, dur } for each event in the pattern array.
An "event" is an index i where array\[i] > 0, meaning the note starts at i and
extends for array\[i] steps in total.

#### Parameters

*   `array` &#x20;

### \_occupiedByExisting

Returns true if `index` is inside any existing event. i.e. pattern\[index0] with dur> (index-index0).

#### Parameters

*   `array` &#x20;
*   `index` &#x20;

### getLength

The pattern length in steps

### getNotes

Called each step by LiveLoop. We look up whether this step is the start of a note,
adapt pitch/velocity from chordManager + energyManager, then return the note if any.
If the pattern array says "2" at step 0, that means from step0..1 is one note event.
But we only trigger noteOn at step0. The next step1 is "covered" by that note, so no new noteOn.

#### Parameters

*   `stepIndex` &#x20;
*   `context`   (optional, default `{}`)

### \_chooseChordNote

Weighted approach to pick chord tones. Possibly approach ±1 semitone if tension=high.

#### Parameters

*   `chordNotes` &#x20;
*   `tension` &#x20;

### \_computeVelocity

Example velocity shaping: hype=medium => +10, hype=high => +20.
Downbeat => +10, offbeat => -10. (If rhythmManager is provided.)

#### Parameters

*   `hype` &#x20;
*   `stepIndex` &#x20;
*   `rhythmManager` &#x20;

### \_noteNameToMidi

Minimal note name -> MIDI parse. E.g. "C4" => 60

#### Parameters

*   `noteName` &#x20;

### \_toNoteName

Minimal MIDI -> note name. E.g. 60 => "C4".

#### Parameters

*   `midiVal` &#x20;

## LFO

src/lfo.js

A Low-Frequency Oscillator (LFO) generates wave values (sine, triangle, etc.)
at a given `frequency` and `amplitude`, optionally offset, and can map the
resulting wave to a MIDI CC range (e.g., 0–127).

**Typical Usage**:

```js
import { LFO } from "op-xy-live";

// Create a basic LFO
const myLfo = new LFO({
  frequency: 1.5,         // cycles per second (if you treat deltaTime as seconds)
  amplitude: 1.0,         // wave amplitude
  offset: 0.0,            // shifts the output value up/down
  shape: "sine",          // wave shape
  targetParam: "filterCutoff", // if integrated with a deviceDefinition mapping
  minCcValue: 30,         // wave minimum maps to CC=30
  maxCcValue: 100,        // wave maximum maps to CC=100
});

// Each update cycle (for example, each 1/60 second or each audio frame):
const deltaTime = 1/60;
const value = myLfo.update(deltaTime);
// 'value' is now the wave output (already mapped if targetParam is set).
```

### Parameters

*   `$0` **[Object][144]**  (optional, default `{}`)

    *   `$0.frequency`   (optional, default `1.0`)
    *   `$0.amplitude`   (optional, default `1.0`)
    *   `$0.offset`   (optional, default `0.0`)
    *   `$0.phase`   (optional, default `0.0`)
    *   `$0.shape`   (optional, default `"sine"`)
    *   `$0.useRadians`   (optional, default `true`)
    *   `$0.targetParam`   (optional, default `null`)
    *   `$0.minCcValue`   (optional, default `0`)
    *   `$0.maxCcValue`   (optional, default `127`)

### reset

Reset the oscillator's phase (and clears any memory of absolute time).

#### Parameters

*   `phase` **[number][142]** If `useRadians=true`, a value in \[0..2π).
    If `useRadians=false`, a value in \[0..1). (optional, default `0`)

## ExplicitNotePattern

**Extends BasePattern**

### Parameters

*   `notesArray` &#x20;

## ContourMelodyOptions

Type: [Object][144]

### Properties

*   `contour` **[Array][143]<[number][142]>?** An array of integers representing "chord-tone index offsets" or steps in chord-tone space.
    Example: \[0, 1, 2, 1, -1].
    Index 0 = chord root (the 0th note in chordManager.getCurrentChordNotes()).
    Index 1 = next chord tone, etc.
    Negative offsets step backward in the chord tones array.
*   `length` **[number][142]?** The number of steps before the pattern conceptually loops.
*   `allowRests` **[boolean][145]?** If true, you can randomly skip steps or rest.
*   `restProbability` **[number][142]?** Probability (0..100) of generating a rest on a given step (only if allowRests=true).
*   `spiceProbability` **[number][142]?** Probability (0..100) that we deviate from the pure chord tone to an approach/dissonance note.
    Higher tension might also increase this.
*   `randomFn` **[function][146]?** A custom random function for deterministic usage in tests.

## DrumPattern

**Extends BasePattern**

DrumPattern is a Pattern class that automatically generates "low", "medium",
and "high" intensity versions of a specified drum pattern. By default, it
uses the "medium" version, but it can adapt to "low" or "high" when
orchestrated by an EnergyManager (or via a manual method call).

### Example Usage

```js
import { DrumPattern } from "op-xy-live/patterns/drum-pattern.js";

// The pattern is an object where each key is a "drum part" (e.g. "kick", "snare"),
// and each value is an array of 0/1 indicating hits. Each array should have
// 'patternLength' steps. (1 = hit, 0 = no hit)
const mediumDrums = {
  kick:  [1,0,0,0,1,0,0,0, 1,0,0,0,1,0,0,0],
  snare: [0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1],
  hat:   [1,1,0,1,1,1,0,1, 1,1,0,1,1,1,0,1]
};

// drumMap optionally translates part names to MIDI note names (or any note naming system).
// If not provided, the code will fall back to "C3" for unspecified drums.
const drumMap = {
  kick: "C2",
  snare: "D2",
  hat: "F#2"
};

// Create a DrumPattern that has "low", "medium", and "high" variants
// automatically derived from 'mediumDrums'.
const drumPattern = new DrumPattern({
  mediumPattern: mediumDrums,
  drumMap,
  patternLength: 16
});

// In a LiveLoop:
const loop = new LiveLoop(midiBus, {
  pattern: drumPattern,
  context: { energyManager, rhythmManager },
  name: "Drums",
  role: "kickProvider",
});
```

### Parameters

*   `$0` **[Object][144]**  (optional, default `{}`)

    *   `$0.mediumPattern` &#x20;
    *   `$0.drumMap`   (optional, default `{}`)
    *   `$0.patternLength`   (optional, default `16`)

### getNotes

Called on each step by the LiveLoop. Determines which variant ("low","medium","high")
to use based on hype level from `energyManager` or from `context.energyState`.
Then returns note objects for any hits on this step. Also, if we see a "kick" drum
hit, we set `rhythmManager.setKickOnThisBeat(true)`.

#### Parameters

*   `stepIndex` **[number][142]**&#x20;
*   `context` **[Object][144]?** Typically includes { energyManager, rhythmManager }, or possibly { energyState }.

Returns **[Array][143]<{note: [string][141], velocity: [number][142], durationSteps: [number][142]}>**&#x20;

### getLength

Returns the total number of steps in this pattern’s loop. Usually 16.

Returns **[number][142]**&#x20;

### setHypeLevel

Allows manual override of hype level if you’re not using context.energyManager.

#### Parameters

*   `level` **[string][141]** "low", "medium", or "high"

## createPhrasePattern

meta-phrase-pattern.js

Provides a function `createPhrasePattern` that combines any two existing patterns
(main vs. fill) into a single "meta pattern." By default, it repeats
4 bars of main + 1 bar of fill, but you can configure any ratio of main vs fill bars.

Usage:
import { createPhrasePattern } from './meta-phrase-pattern.js';
import { DrumPattern } from './patterns/drum-pattern.js'; // e.g.

const mainDrum = new DrumPattern(...);
const fillDrum = new DrumPattern(...);

const phrasedDrumPattern = createPhrasePattern(
mainDrum,
fillDrum,
{
barsOfMain: 4,
barsOfFill: 1,
barLengthInSteps: 16,
onPhraseStart: (phraseIndex) => console.log('New phrase started:', phraseIndex),
onPhraseEnd: (phraseIndex) => console.log('Phrase ended:', phraseIndex),
}
);

// Then in your LiveLoop:
const loop = new LiveLoop(midiBus, {
pattern: phrasedDrumPattern,
...
});

### Parameters

*   `mainPattern` &#x20;
*   `fillPattern` &#x20;
*   `$2` **[Object][144]**  (optional, default `{}`)

    *   `$2.barsOfMain`   (optional, default `4`)
    *   `$2.barsOfFill`   (optional, default `1`)
    *   `$2.barLengthInSteps`   (optional, default `16`)
    *   `$2.onPhraseStart`   (optional, default `null`)
    *   `$2.onPhraseEnd`   (optional, default `null`)

## createPhrasePattern

Wraps two existing patterns (main and fill) into a single meta-pattern
that alternates 4 bars of main and 1 bar of fill, repeating indefinitely.

You can pass ANY pattern object for mainPattern or fillPattern, as long as
it implements `getNotes(stepIndex, context)` and `getLength()`.

### Parameters

*   `mainPattern` **[object][144]** An existing pattern implementing {getNotes, getLength}
*   `fillPattern` **[object][144]** Another pattern, used for the "fill" measure
*   `options` **[PhrasePatternOptions][101]**  (optional, default `{}`)

    *   `options.barsOfMain`   (optional, default `4`)
    *   `options.barsOfFill`   (optional, default `1`)
    *   `options.barLengthInSteps`   (optional, default `16`)
    *   `options.onPhraseStart`   (optional, default `null`)
    *   `options.onPhraseEnd`   (optional, default `null`)

## PhrasePatternOptions

Type: [Object][144]

### Properties

*   `barsOfMain` **[number][142]?** Number of bars (measures) to use the mainPattern.
*   `barsOfFill` **[number][142]?** Number of bars (measures) to use the fillPattern.
*   `barLengthInSteps` **[number][142]?** How many steps in one bar. Typically 16 if you're doing 4/4 with each quarter = 4 steps.
*   `onPhraseStart` **[function][146]?** Callback when a phrase starts. (phraseIndex) => void
*   `onPhraseEnd` **[function][146]?** Callback when a phrase ends.   (phraseIndex) => void

## LiveLoop

src/live-loop.js

A LiveLoop class manages the playback logic for a single musical part or track.
It holds:

*   A Pattern (implementing `getNotes(stepIndex, context)` and `getLength()`)
*   An array of LFOs for parameter modulation
*   An internal list of active notes, so it can schedule `noteOff` events
    based on duration.

This class does NOT directly start or stop the transport; it relies on an
external TransportManager to call `tick()` on every step, and optionally
`updateLFOsOnly()` on high-resolution pulses. In typical usage, you won't
call these methods yourself; the TransportManager handles it.

### Example Usage

```js
import { LiveLoop, ExplicitNotePattern, LFO } from "op-xy-live";
import { MidiBus } from "op-xy-live";  // or a shared instance

// 1) Create a MIDI bus
const midiBus = new MidiBus();

// 2) Define a simple pattern (e.g., a short 4-step melodic line)
const myPattern = new ExplicitNotePattern([
  "C4", "E4", "G4", "B4"
]);

// 3) (Optional) Create an LFO that modulates filterCutoff
const myLFO = new LFO({ targetParam: "filterCutoff", frequency: 0.5 });

// 4) Create a LiveLoop that uses the pattern and LFO
const myLoop = new LiveLoop(midiBus, {
  pattern: myPattern,
  midiChannel: 1,
  lfos: [myLFO],
  name: "Melody"
});

// 5) (Optional) Add it to a TransportManager that calls myLoop.tick() for us
// ...

// 6) Change the pattern or transpose in real time:
myLoop.setTranspose(2); // shift up by 2 semitones
myLoop.setPattern(someOtherPattern, false); // queue new pattern for next cycle

// 7) Chaining Mode Example:
//    Provide 'cycles' to the constructor, then chain more sub-loops.
const chainLoop = new LiveLoop(midiBus, {
  pattern: patternA,
  cycles: 2   // how many times patternA should repeat
})
.chainLiveLoop({ pattern: patternB, cycles: 4 })
.chainLiveLoop({ pattern: patternC, cycles: 1 })
.onChainComplete(() => {
  console.log("All chained patterns completed!");
});
```

### Parameters

*   `midiBus` &#x20;
*   `$1` **[Object][144]**  (optional, default `{}`)

    *   `$1.pattern` &#x20;
    *   `$1.lfos`   (optional, default `[]`)
    *   `$1.midiChannel`   (optional, default `1`)
    *   `$1.context`   (optional, default `{}`)
    *   `$1.globalContext`   (optional, default `null`)
    *   `$1.name`   (optional, default `""`)
    *   `$1.muted`   (optional, default `false`)
    *   `$1.transpose`   (optional, default `0`)
    *   `$1.deviceDefinition`   (optional, default `null`)
    *   `$1.deviceManager`   (optional, default `null`)
    *   `$1.midiOutputId`   (optional, default `null`)
    *   `$1.cycles`   (optional, default `null`)
    *   `$1.role`   (optional, default `null`)

### midiOutputId

Return the currently assigned MIDI output ID (if any).

### midiOutputId

Assign a new MIDI output ID, and optionally re-fetch deviceDefinition if available.

#### Parameters

*   `newId` &#x20;

### device

Returns the device instance (from deviceManager) if we have a valid \_midiOutputId.

### setParam

Sends a CC for the given paramName if the device supports it.

#### Parameters

*   `paramName` **[string][141]**&#x20;
*   `value` **[number][142]** 0..127

### getPatternName

Returns either the pattern.options.name (if defined) or the pattern's constructor name.

Returns **[string][141]**&#x20;

### getApproximatePitch

Returns the average MIDI note of all noteOn events triggered so far.
This includes adjustments for the loop's current transpose setting.
If none have been triggered, returns null.

Returns **([number][142] | null)**&#x20;

### chainLiveLoop

chainLiveLoop(params) - Add another sub-loop to the chain.

Use this to chain multiple patterns one after another, each repeating
for its specified `cycles` count. For example:

```js
const chainLoop = new LiveLoop(midiBus, { pattern: patA, cycles: 2 })
  .chainLiveLoop({ pattern: patB, cycles: 4 })
  .chainLiveLoop({ pattern: patC, cycles: 8 })
  .onChainComplete(() => console.log("All done"));
```

#### Parameters

*   `params` **[object][144]**  (optional, default `{}`)

    *   `params.pattern` **[object][144]** The pattern for this chained segment
    *   `params.cycles` **[number][142]** How many times to repeat the pattern (optional, default `1`)
    *   `params.midiChannel` **[number][142]?** Optional override of MIDI channel
    *   `params.role` **[string][141]** The role of the pattern (optional, default `null`)

Returns **[LiveLoop][103]** this

### onChainComplete

onChainComplete(callback) - Called once the final chain item finishes.
If no chain is used, this never fires.

Example:

```js
new LiveLoop(midiBus, { pattern: patA, cycles: 2 })
  .chainLiveLoop({ pattern: patB, cycles: 4 })
  .onChainComplete(() => {
    console.log("All patterns in the chain have finished!");
  });
```

#### Parameters

*   `callback` **[function][146]** A function to run when the chain is fully complete

Returns **[LiveLoop][103]** this

### updateLFOsOnly

If called at a higher resolution (e.g. every audio callback),
updates LFOs alone. Optional feature for smoother parameter automation.

#### Parameters

*   `deltaTime` **[number][142]** time in beats since last call
*   `absoluteTime` **[number][142]**  (optional, default `null`)

### setPattern

Immediately replaces the current pattern or queues the change to occur
at the next pattern boundary (start of pattern).

#### Parameters

*   `newPattern` **[object][144]**&#x20;
*   `immediate` **[boolean][145]**  (optional, default `false`)

### addLFO

Add an LFO immediately.

#### Parameters

*   `lfo` **[object][144]**&#x20;

### updateLFO

Update properties of an existing LFO (immediately or queued).

#### Parameters

*   `index` **[number][142]**&#x20;
*   `newProps` **[object][144]**&#x20;
*   `immediate` **[boolean][145]**  (optional, default `false`)

### setContext

Sets or updates the local context. The pattern receives this context each
step in `getNotes(stepIndex, context)`.

#### Parameters

*   `context` **[object][144]**&#x20;
*   `immediate` **[boolean][145]**  (optional, default `true`)

### setGlobalContext

Sets or updates the global context reference.
Typically contains managers (energyManager, chordManager, etc.).

#### Parameters

*   `globalContext` **[object][144]**&#x20;

### setMuted

Mutes or unmutes the loop.

#### Parameters

*   `bool` **[boolean][145]**&#x20;

### setTranspose

Sets semitone transposition.

#### Parameters

*   `semitones` **[number][142]**&#x20;

### setName

Assign a descriptive name.

#### Parameters

*   `name` **[string][141]**&#x20;

## getNotes

Called each step by the LiveLoop. We read the current chord from chordManager
(just root + chord notes). If there’s no chord, we can throw an error or return \[].
Then we pick the next chord tone according to `this.contour`, possibly apply spice,
and return a single note.

### Parameters

*   `stepIndex` **[number][142]**&#x20;
*   `context` **[object][144]** Typically includes { chordManager, energyManager, rhythmManager, ... } (optional, default `{}`)

Returns **[Array][143]<{note: [string][141], velocity: [number][142], durationSteps: [number][142]}>**&#x20;

## getLength

Return the pattern length in steps. Typically the LiveLoop uses this to loop the pattern,
though the chord changes come from chordManager (already updated by the chord provider).

Returns **[number][142]**&#x20;

## reset

Resets internal state if needed. For instance, resets \_currentContourIndex to 0.

## toConfig

For debugging or serialization.

Returns **[Object][144]**&#x20;

