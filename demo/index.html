<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tonic Midi</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 1rem;
        background: #f0f0f0;
      }
      fieldset {
        margin-bottom: 1rem;
        border: 1px solid #ccc;
        padding: 1rem;
        background: #fff;
      }
      fieldset > legend {
        font-size: 1.2rem;
        font-weight: bold;
      }
      label {
        display: inline-block;
        width: 180px;
        font-weight: 600;
        margin-top: 0.2rem;
      }
      button {
        margin-top: 0.5rem;
      }
      .param-row {
        margin-bottom: 0.3rem;
      }
      ul {
        list-style-type: none;
        padding: 0;
      }
      ul li {
        margin: 0.3rem 0;
      }
      ul li button {
        margin-left: 0.5rem;
      }
    </style>
  </head>
  <body>
    <h1>Tonic Midi</h1>
    <p>
      This page is a personal project demonstrating how to build generative
      music with chord swells, evolving drums, and melodic phrases. It reacts to
      an
      <em>external MIDI clock</em>, so press play on a hardware or software
      sequencer that sends clock, and the patterns will sync up automatically.
    </p>

    <!-- 1) COLORFUL CHORD SWELL -->
    <fieldset>
      <legend>Colorful Chord Swell Pattern</legend>
      <p style="max-width: 600px">
        This pattern selects a musical scale based on “color” and creates chords
        that swell into each other. Adjust how long chords last
        (<em>swellDuration</em>), how they overlap, and how many chord
        extensions (<em>chordComplexity</em>) are added.
      </p>
      <div class="param-row">
        <label for="colorSelect">color:</label>
        <select id="colorSelect">
          <option value="warm" selected>Warm</option>
          <option value="bright">Bright</option>
          <option value="dark">Dark</option>
          <option value="mysterious">Mysterious</option>
        </select>
      </div>
      <div class="param-row">
        <label for="swellDuration">swellDuration (steps):</label>
        <input type="number" id="swellDuration" min="1" max="64" value="16" />
      </div>
      <div class="param-row">
        <label for="overlap">overlap (steps):</label>
        <input type="number" id="overlap" min="-8" max="8" value="2" />
      </div>
      <div class="param-row">
        <label for="chordComplexity">chordComplexity (0..1):</label>
        <input
          type="range"
          id="chordComplexity"
          min="0"
          max="1"
          step="0.1"
          value="0.5"
        />
      </div>
      <button id="updateChordBtn">Update Chord Pattern</button>
    </fieldset>

    <!-- 2) EVOLVING DRUM PATTERN -->
    <fieldset>
      <legend>Evolving Drum Pattern</legend>
      <p style="max-width: 600px">
        This drum pattern morphs in real time while holding onto a core groove.
        <em>drumIntensity</em> controls how dense the hits get, and
        <em>flavor</em> picks the characteristic style.
      </p>
      <div class="param-row">
        <label for="drumIntensity">drumIntensity (0..1):</label>
        <input
          type="range"
          id="drumIntensity"
          min="0"
          max="1"
          step="0.1"
          value="0.5"
        />
      </div>
      <div class="param-row">
        <label for="flavorSelect">flavor:</label>
        <select id="flavorSelect">
          <option value="ambient" selected>ambient</option>
          <option value="tribal">tribal</option>
          <option value="electronic">electronic</option>
          <option value="lofi">lofi</option>
        </select>
      </div>
      <button id="updateDrumsBtn">Update Drum Pattern</button>
    </fieldset>

    <!-- 3) PHRASE CONTOUR MELODY -->
    <fieldset>
      <legend>PhraseContourMelody (Melody on channel 5)</legend>
      <p style="max-width: 600px">
        A multi-bar melodic line divided into subSections like “build” or
        “peak.” You can define how many bars the phrase lasts, steps per bar,
        and how often “spice” (approach notes) appears. The pattern re-shapes
        each time it completes a phrase.
      </p>
      <div class="param-row">
        <label for="phraseBars">phraseBars:</label>
        <input type="number" id="phraseBars" min="1" max="16" value="4" />
      </div>
      <div class="param-row">
        <label for="subSections">subSections (comma-sep):</label>
        <input
          type="text"
          id="subSections"
          value="intro,build,peak,resolve,cadence"
          size="30"
        />
      </div>
      <div class="param-row">
        <label for="stepsPerBar">stepsPerBar:</label>
        <input type="number" id="stepsPerBar" min="4" max="64" value="16" />
      </div>
      <div class="param-row">
        <label for="cadenceBeats">cadenceBeats:</label>
        <input type="number" id="cadenceBeats" min="0" max="8" value="2" />
      </div>
      <div class="param-row">
        <label for="melodicDensity">melodicDensity (0..1):</label>
        <input
          type="range"
          id="melodicDensity"
          min="0"
          max="1"
          step="0.1"
          value="0.7"
        />
      </div>
      <div class="param-row">
        <label for="baseVelocity">baseVelocity (1..127):</label>
        <input type="number" id="baseVelocity" min="1" max="127" value="90" />
      </div>
      <div class="param-row">
        <label for="tensionEmbellishProb">tensionEmbellishProb (0..1):</label>
        <input
          type="range"
          id="tensionEmbellishProb"
          min="0"
          max="1"
          step="0.1"
          value="0.2"
        />
      </div>
      <button id="updateMelodyBtn">Update Melody Pattern</button>
    </fieldset>

    <!-- 4) ENERGY CONTROLS -->
    <fieldset>
      <legend>Energy Manager Controls</legend>
      <p style="max-width: 600px">
        These quick switches alter “hype” (how busy/loud everything is) and
        “tension” (how dissonant or stable chord/melody structures become). This
        is a handy shortcut for performing live arrangement changes.
      </p>
      <div>
        <button data-hype="low">Set Hype: LOW</button>
        <button data-hype="medium">Set Hype: MEDIUM</button>
        <button data-hype="high">Set Hype: HIGH</button>
      </div>
      <div style="margin-top: 0.5rem">
        <button data-tension="none">Set Tension: NONE</button>
        <button data-tension="low">Set Tension: LOW</button>
        <button data-tension="mid">Set Tension: MID</button>
        <button data-tension="high">Set Tension: HIGH</button>
      </div>
    </fieldset>

    <!-- 5) REAL-TIME LFO MANAGER -->
    <fieldset>
      <legend>Real-Time LFOs</legend>
      <p style="max-width: 600px">
        Add continuous LFO modulation to any MIDI channel, layered on top of
        your existing patterns. Multiple LFOs can affect the same channel.
      </p>
      <div class="param-row">
        <label for="lfoChannelSelect">MIDI Channel:</label>
        <select id="lfoChannelSelect">
          <option value="1">Channel 1</option>
          <option value="2">Channel 2</option>
          <option value="3">Channel 3</option>
          <option value="4">Channel 4</option>
          <option value="5">Channel 5</option>
          <option value="6">Channel 6</option>
          <option value="7">Channel 7</option>
          <option value="8">Channel 8</option>
          <option value="9">Channel 9</option>
          <option value="10">Channel 10</option>
          <option value="11">Channel 11</option>
          <option value="12">Channel 12</option>
          <option value="13">Channel 13</option>
          <option value="14">Channel 14</option>
          <option value="15">Channel 15</option>
          <option value="16">Channel 16</option>
        </select>
      </div>
      <div class="param-row">
        <label for="lfoPresetSelect">LFO Preset:</label>
        <select id="lfoPresetSelect">
          <!-- Sample "fast" LFO presets -->
          <option value="lightVibrato">Light Vibrato</option>
          <option value="rapidFilterFlutter">Rapid Filter Flutter</option>
          <option value="squareTremolo">Square-Wave Tremolo</option>
          <option value="pingPongPan">Ping-Pong Pan</option>
          <option value="wobblyResonance">Wobbly Resonance</option>
          <option value="subtleChorus">Subtle Chorus</option>
          <option value="stutterGate">Stutter Gate</option>
          <option value="fmClang">FM Clang</option>
        </select>
      </div>
      <button id="addLfoBtn">Add LFO</button>

      <h4>Active LFOs:</h4>
      <ul id="activeLfoList"></ul>
    </fieldset>

    <!-- 6) ARRANGEMENT ONE-SHOTS -->
    <fieldset>
      <legend>Arrangement Sweeps / One-Shots</legend>
      <p style="max-width: 600px">
        Schedule a single, multi-step sweep (e.g., slowly opening a filter) that
        starts at the next bar boundary, runs once, and then finishes. Choose a
        channel, a duration in steps, and a preset.
      </p>
      <div class="param-row">
        <label for="oneShotChannelSelect">MIDI Channel:</label>
        <select id="oneShotChannelSelect">
          <option value="1">Channel 1</option>
          <option value="2">Channel 2</option>
          <option value="3">Channel 3</option>
          <option value="4">Channel 4</option>
          <option value="5">Channel 5</option>
          <option value="6">Channel 6</option>
          <option value="7">Channel 7</option>
          <option value="8">Channel 8</option>
          <option value="9">Channel 9</option>
          <option value="10">Channel 10</option>
          <option value="11">Channel 11</option>
          <option value="12">Channel 12</option>
          <option value="13">Channel 13</option>
          <option value="14">Channel 14</option>
          <option value="15">Channel 15</option>
          <option value="16">Channel 16</option>
        </select>
      </div>
      <div class="param-row">
        <label for="oneShotLengthSelect">Duration (steps):</label>
        <select id="oneShotLengthSelect">
          <option value="16">16 Steps</option>
          <option value="32">32 Steps</option>
          <option value="64">64 Steps</option>
        </select>
      </div>
      <div class="param-row">
        <label for="oneShotSweepSelect">Sweep Preset:</label>
        <select id="oneShotSweepSelect">
          <!-- Sample "slow" LFO presets -->
          <option value="slowFilterRise">Slow Filter Rise</option>
          <option value="deepBreathingPad">Deep Breathing Pad</option>
          <option value="swellingResonance">Swelling Resonance</option>
          <option value="verySlowRandomDrift">Very Slow Random Drift</option>
        </select>
      </div>
      <button id="enqueueSweepBtn">Enqueue Sweep</button>

      <h4>Queued Sweeps:</h4>
      <ul id="queuedSweepList"></ul>
    </fieldset>

    <p style="margin-top: 2rem; max-width: 700px">
      Try changing flavors, note durations, chord complexities, or hype/tension
      levels at any time. I'm continuing to build out new pattern ideas and ways
      of chaining them together. The goal is a simple browser-based setup that
      hooks to your hardware via Web MIDI, letting you spontaneously jam
      evolving tracks without a DAW.
    </p>

    <script type="module">
      import { createDefaultSystem } from "../src/system/create-default-system.js";
      import {
        LiveLoop,
        ColorfulChordSwellPattern,
        EvolvingLockedDrumPattern,
        PhraseContourMelody,
        LFO,
      } from "../src/index.js";

      // Example Fast LFO Presets
      const LFO_PRESETS_FAST = {
        lightVibrato: {
          shape: "sine",
          frequency: 6.0,
          amplitude: 5,
          targetParam: "pitch_bend",
        },
        rapidFilterFlutter: {
          shape: "triangle",
          frequency: 9.0,
          amplitude: 20,
          targetParam: "filterCutoff",
        },
        squareTremolo: {
          shape: "square",
          frequency: 5.0,
          amplitude: 80,
          targetParam: "trackVolume",
        },
        pingPongPan: {
          shape: "triangle",
          frequency: 4.0,
          amplitude: 127,
          targetParam: "trackPan",
        },
        wobblyResonance: {
          shape: "sine",
          frequency: 4.0,
          amplitude: 25,
          targetParam: "resonance",
        },
        subtleChorus: {
          shape: "sine",
          frequency: 2.5,
          amplitude: 5,
          targetParam: "pitch_bend",
        },
        stutterGate: {
          shape: "sawDown",
          frequency: 8.0,
          amplitude: 30,
          targetParam: "trackVolume",
        },
        fmClang: {
          shape: "random",
          frequency: 10.0,
          amplitude: 15,
          targetParam: "pitch_bend",
        },
      };

      // Example Slow LFO Presets (One-Shot Sweeps)
      const LFO_PRESETS_SLOW = {
        slowFilterRise: {
          shape: "sine",
          frequency: 0.05,
          amplitude: 80,
          targetParam: "filterCutoff",
        },
        deepBreathingPad: {
          shape: "triangle",
          frequency: 0.03,
          amplitude: 40,
          targetParam: "trackVolume",
        },
        swellingResonance: {
          shape: "sine",
          frequency: 0.02,
          amplitude: 60,
          targetParam: "resonance",
        },
        verySlowRandomDrift: {
          shape: "random",
          frequency: 0.01,
          amplitude: 20,
          targetParam: "filterCutoff",
        },
      };

      // Real-time LFO store
      const activeLFOs = [];

      // One-shot sweeps store
      const queuedOneShots = [];

      (async function main() {
        const system = await createDefaultSystem();
        const {
          transport,
          energyManager,
          chordManager,
          globalContext,
          midiOutputs,
        } = system;

        globalContext.energyManager = energyManager;
        globalContext.chordManager = chordManager;
        chordManager.authorizeProvider("ColorfulChordSwellPattern");

        // Patterns & Loops
        let chordPattern = new ColorfulChordSwellPattern({
          color: "warm",
          swellDuration: 16,
          overlap: 2,
          chordComplexity: 0.5,
        });
        const chordLoop = new LiveLoop(system.midiBus, {
          pattern: chordPattern,
          midiChannel: 8,
          name: "ColorfulChordLoop",
          role: "chordProvider",
          globalContext,
          deviceManager: system.deviceManager,
          midiOutputId: midiOutputs[0]?.id,
        });

        let drumPattern = new EvolvingLockedDrumPattern({
          patternLength: 16,
          drumIntensity: 0.5,
          flavor: "ambient",
          deviceDefinition: system.deviceManager.getDeviceForOutput(
            midiOutputs[0]?.id
          ),
        });
        const drumLoop = new LiveLoop(system.midiBus, {
          pattern: drumPattern,
          midiChannel: 1,
          name: "EvolvingDrums",
          role: "kickProvider",
          globalContext,
          deviceManager: system.deviceManager,
          midiOutputId: midiOutputs[0]?.id,
        });

        let melodyPattern = new PhraseContourMelody({
          phraseBars: 4,
          subSections: ["intro", "build", "peak", "resolve", "cadence"],
          stepsPerBar: 16,
          cadenceBeats: 2,
          melodicDensity: 0.7,
          baseVelocity: 90,
          tensionEmbellishProb: 0.2,
        });
        const melodyLoop = new LiveLoop(system.midiBus, {
          pattern: melodyPattern,
          midiChannel: 5,
          name: "PhraseMelody",
          role: null,
          globalContext,
          deviceManager: system.deviceManager,
          midiOutputId: midiOutputs[0]?.id,
        });

        transport.addLiveLoop(chordLoop);
        transport.addLiveLoop(drumLoop);
        transport.addLiveLoop(melodyLoop);

        // Hook into the transport's clock pulses to update LFOs & sweeps:
        // We'll monkey-patch or add a small hook to the TransportManager
        const originalClockFn = transport._onClockPulse.bind(transport);
        transport._onClockPulse = function (message) {
          // call original
          originalClockFn(message);
          // do our LFO updates
          const deltaTime = 1.0 / 24.0; // approximate for each pulse in beats
          updateAllLFOs(deltaTime, this.timeInBeats);
          checkOneShots(this.stepIndex, deltaTime);
        };

        console.log("System ready! Press play on external clock...");

        //-------------------------
        //  Chord pattern controls
        //-------------------------
        const colorSelect = document.getElementById("colorSelect");
        const swellDurationInput = document.getElementById("swellDuration");
        const overlapInput = document.getElementById("overlap");
        const chordComplexityInput = document.getElementById("chordComplexity");
        document
          .getElementById("updateChordBtn")
          .addEventListener("click", () => {
            const newColor = colorSelect.value;
            const newSwell = parseInt(swellDurationInput.value, 10) || 16;
            const newOverlap = parseInt(overlapInput.value, 10) || 0;
            const newComplex = parseFloat(chordComplexityInput.value) || 0.5;

            chordPattern = new ColorfulChordSwellPattern({
              color: newColor,
              swellDuration: newSwell,
              overlap: newOverlap,
              chordComplexity: newComplex,
            });
            chordLoop.setPattern(chordPattern, true);
            console.log(
              "ChordPattern updated =>",
              newColor,
              newSwell,
              newOverlap,
              newComplex
            );
          });

        //-------------------------
        // Drum pattern controls
        //-------------------------
        const drumIntensityRange = document.getElementById("drumIntensity");
        const flavorSelect = document.getElementById("flavorSelect");
        document
          .getElementById("updateDrumsBtn")
          .addEventListener("click", () => {
            const newIntensity = parseFloat(drumIntensityRange.value) || 0.5;
            const newFlavor = flavorSelect.value;

            drumPattern = new EvolvingLockedDrumPattern({
              patternLength: 16,
              drumIntensity: newIntensity,
              flavor: newFlavor,
              deviceDefinition: system.deviceManager.getDeviceForOutput(
                midiOutputs[0]?.id
              ),
            });
            drumLoop.setPattern(drumPattern, true);

            console.log("DrumPattern updated =>", newIntensity, newFlavor);
          });

        //-------------------------
        // Melody pattern controls
        //-------------------------
        const phraseBarsEl = document.getElementById("phraseBars");
        const subSectionsEl = document.getElementById("subSections");
        const stepsPerBarEl = document.getElementById("stepsPerBar");
        const cadenceBeatsEl = document.getElementById("cadenceBeats");
        const melodicDensityEl = document.getElementById("melodicDensity");
        const baseVelocityEl = document.getElementById("baseVelocity");
        const tensionEmbellishEl = document.getElementById(
          "tensionEmbellishProb"
        );

        document
          .getElementById("updateMelodyBtn")
          .addEventListener("click", () => {
            const pb = parseInt(phraseBarsEl.value, 10) || 4;
            const subsArray = subSectionsEl.value
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s.length > 0);
            const spb = parseInt(stepsPerBarEl.value, 10) || 16;
            const cadBeats = parseFloat(cadenceBeatsEl.value) || 2;
            const density = parseFloat(melodicDensityEl.value) || 0.7;
            const baseVel = parseInt(baseVelocityEl.value, 10) || 90;
            const tProb = parseFloat(tensionEmbellishEl.value) || 0.2;

            melodyPattern = new PhraseContourMelody({
              phraseBars: pb,
              subSections: subsArray.length
                ? subsArray
                : ["build", "peak", "resolve"],
              stepsPerBar: spb,
              cadenceBeats: cadBeats,
              melodicDensity: density,
              baseVelocity: baseVel,
              tensionEmbellishProb: tProb,
            });
            melodyLoop.setPattern(melodyPattern, true);

            console.log(
              "MelodyPattern updated =>",
              "phraseBars:",
              pb,
              "subSections:",
              subsArray,
              "stepsPerBar:",
              spb,
              "cadenceBeats:",
              cadBeats,
              "density:",
              density,
              "baseVelocity:",
              baseVel,
              "tensionEmbellishProb:",
              tProb
            );
          });

        //-------------------------
        // Energy controls
        //-------------------------
        document.querySelectorAll("button[data-hype]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const newHype = btn.getAttribute("data-hype");
            energyManager.setHypeLevel(newHype);
            console.log("EnergyManager setHypeLevel:", newHype);
          });
        });
        document.querySelectorAll("button[data-tension]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const newTension = btn.getAttribute("data-tension");
            energyManager.setTensionLevel(newTension);
            console.log("EnergyManager setTensionLevel:", newTension);
          });
        });

        //-------------------------
        // Real-time LFO manager
        //-------------------------
        document.getElementById("addLfoBtn").addEventListener("click", () => {
          const channel = parseInt(
            document.getElementById("lfoChannelSelect").value,
            10
          );
          const presetKey = document.getElementById("lfoPresetSelect").value;
          const preset = LFO_PRESETS_FAST[presetKey];

          if (!preset) return;

          const myLfo = new LFO({
            shape: preset.shape,
            frequency: preset.frequency,
            amplitude: preset.amplitude,
            targetParam: preset.targetParam,
          });

          const lfoObj = { channel, presetKey, lfo: myLfo };
          activeLFOs.push(lfoObj);
          renderActiveLFOList();
        });

        function renderActiveLFOList() {
          const listEl = document.getElementById("activeLfoList");
          listEl.innerHTML = "";
          activeLFOs.forEach((obj, idx) => {
            const li = document.createElement("li");
            li.textContent = `CH${obj.channel} - ${obj.presetKey}`;
            const removeBtn = document.createElement("button");
            removeBtn.textContent = "X";
            removeBtn.onclick = () => {
              activeLFOs.splice(idx, 1);
              renderActiveLFOList();
            };
            li.appendChild(removeBtn);
            listEl.appendChild(li);
          });
        }

        function updateAllLFOs(deltaTime, absoluteTime) {
          // For each active LFO, update & send CC
          activeLFOs.forEach(({ channel, lfo }) => {
            const value = lfo.update(deltaTime);
            const deviceDef = system.deviceManager.getDeviceForOutput(
              system.midiOutputs[0]?.id
            );
            if (!deviceDef) return;
            const ccNum = deviceDef.getCC(lfo.targetParam);
            if (ccNum == null) return;

            system.midiBus.controlChange({
              channel,
              cc: ccNum,
              value: Math.floor(value),
            });
          });
        }

        //-------------------------
        // Arrangement One-Shots
        //-------------------------
        document
          .getElementById("enqueueSweepBtn")
          .addEventListener("click", () => {
            const channel = parseInt(
              document.getElementById("oneShotChannelSelect").value,
              10
            );
            const steps = parseInt(
              document.getElementById("oneShotLengthSelect").value,
              10
            );
            const presetKey =
              document.getElementById("oneShotSweepSelect").value;
            const preset = LFO_PRESETS_SLOW[presetKey];
            if (!preset) return;

            // We'll do 1 cycle over 'steps' steps if you want a simple approach
            // if each step ~1 beat, freq might be 1 / (steps/4) to do 1 cycle in "steps"
            const freq = 1 / (steps / 4);

            const job = {
              channel,
              steps,
              presetKey,
              lfo: new LFO({
                shape: preset.shape,
                frequency: freq,
                amplitude: preset.amplitude,
                targetParam: preset.targetParam,
              }),
              startStep: null,
              done: false,
            };

            // schedule at next multiple of 16 steps
            const currentStep = transport.stepIndex;
            const nextMultiple16 = Math.ceil(currentStep / 16) * 16;
            job.startStep = nextMultiple16;

            queuedOneShots.push(job);
            renderSweepList();
          });

        function renderSweepList() {
          const listEl = document.getElementById("queuedSweepList");
          listEl.innerHTML = "";
          queuedOneShots.forEach((obj, idx) => {
            if (obj.done) return;
            const li = document.createElement("li");
            li.textContent = `CH${obj.channel} - ${obj.presetKey}, ${obj.steps} steps (start@${obj.startStep})`;
            const removeBtn = document.createElement("button");
            removeBtn.textContent = "X";
            removeBtn.onclick = () => {
              obj.done = true;
              renderSweepList();
            };
            li.appendChild(removeBtn);
            listEl.appendChild(li);
          });
        }

        function checkOneShots(stepIndex, deltaTime) {
          queuedOneShots.forEach((job) => {
            if (job.done) return;
            if (stepIndex < job.startStep) {
              // not started yet
              return;
            }
            const endStep = job.startStep + job.steps;
            if (stepIndex >= endStep) {
              // finished
              job.done = true;
              return;
            }
            // in the active range
            const val = job.lfo.update(deltaTime);
            const deviceDef = system.deviceManager.getDeviceForOutput(
              system.midiOutputs[0]?.id
            );
            if (!deviceDef) return;
            const ccNum = deviceDef.getCC(job.lfo.targetParam);
            if (ccNum == null) return;

            system.midiBus.controlChange({
              channel: job.channel,
              cc: ccNum,
              value: Math.floor(val),
            });
          });
          renderSweepList();
        }
      })();
    </script>
  </body>
</html>
