<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tonic Midi</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 1rem;
        background: #f0f0f0;
      }
      fieldset {
        margin-bottom: 1rem;
        border: 1px solid #ccc;
        padding: 1rem;
        background: #fff;
      }
      fieldset > legend {
        font-size: 1.2rem;
        font-weight: bold;
      }
      label {
        display: inline-block;
        width: 180px;
        font-weight: 600;
        margin-top: 0.2rem;
      }
      button {
        margin-top: 0.5rem;
      }
      .param-row {
        margin-bottom: 0.3rem;
      }
    </style>
  </head>
  <body>
    <h1>Tonic Midi</h1>
    <p>
      This page is a personal project demonstrating how to build generative
      music with chord swells, evolving drums, and melodic phrases. It reacts to
      an
      <em>external MIDI clock</em>, so press play on a hardware or software
      sequencer that sends clock, and the patterns will sync up automatically.
    </p>

    <fieldset>
      <legend>Colorful Chord Swell Pattern</legend>
      <p style="max-width: 600px">
        This pattern selects a musical scale based on “color” and creates chords
        that swell into each other. Adjust how long chords last
        (<em>swellDuration</em>), how they overlap, and how many chord
        extensions (<em>chordComplexity</em>) are added.
      </p>
      <div class="param-row">
        <label for="colorSelect">color:</label>
        <select id="colorSelect">
          <option value="warm" selected>Warm</option>
          <option value="bright">Bright</option>
          <option value="dark">Dark</option>
          <option value="mysterious">Mysterious</option>
        </select>
      </div>
      <div class="param-row">
        <label for="swellDuration">swellDuration (steps):</label>
        <input type="number" id="swellDuration" min="1" max="64" value="16" />
      </div>
      <div class="param-row">
        <label for="overlap">overlap (steps):</label>
        <input type="number" id="overlap" min="-8" max="8" value="2" />
      </div>
      <div class="param-row">
        <label for="chordComplexity">chordComplexity (0..1):</label>
        <input
          type="range"
          id="chordComplexity"
          min="0"
          max="1"
          step="0.1"
          value="0.5"
        />
      </div>
      <button id="updateChordBtn">Update Chord Pattern</button>
    </fieldset>

    <fieldset>
      <legend>Evolving Drum Pattern</legend>
      <p style="max-width: 600px">
        This drum pattern morphs in real time while holding onto a core groove.
        <em>drumIntensity</em> controls how dense the hits get, and
        <em>flavor</em> picks the characteristic style.
      </p>
      <div class="param-row">
        <label for="drumIntensity">drumIntensity (0..1):</label>
        <input
          type="range"
          id="drumIntensity"
          min="0"
          max="1"
          step="0.1"
          value="0.5"
        />
      </div>
      <div class="param-row">
        <label for="flavorSelect">flavor:</label>
        <select id="flavorSelect">
          <option value="ambient" selected>ambient</option>
          <option value="tribal">tribal</option>
          <option value="electronic">electronic</option>
          <option value="lofi">lofi</option>
        </select>
      </div>
      <button id="updateDrumsBtn">Update Drum Pattern</button>
    </fieldset>

    <fieldset>
      <legend>PhraseContourMelody (Melody on channel 5)</legend>
      <p style="max-width: 600px">
        A multi-bar melodic line divided into subSections like “build” or
        “peak.” You can define how many bars the phrase lasts, steps per bar,
        and how often “spice” (approach notes) appears. The pattern re-shapes
        each time it completes a phrase.
      </p>
      <div class="param-row">
        <label for="phraseBars">phraseBars:</label>
        <input type="number" id="phraseBars" min="1" max="16" value="4" />
      </div>
      <div class="param-row">
        <label for="subSections">subSections (comma-sep):</label>
        <input
          type="text"
          id="subSections"
          value="intro,build,peak,resolve,cadence"
          size="30"
        />
      </div>
      <div class="param-row">
        <label for="stepsPerBar">stepsPerBar:</label>
        <input type="number" id="stepsPerBar" min="4" max="64" value="16" />
      </div>
      <div class="param-row">
        <label for="cadenceBeats">cadenceBeats:</label>
        <input type="number" id="cadenceBeats" min="0" max="8" value="2" />
      </div>
      <div class="param-row">
        <label for="melodicDensity">melodicDensity (0..1):</label>
        <input
          type="range"
          id="melodicDensity"
          min="0"
          max="1"
          step="0.1"
          value="0.7"
        />
      </div>
      <div class="param-row">
        <label for="baseVelocity">baseVelocity (1..127):</label>
        <input type="number" id="baseVelocity" min="1" max="127" value="90" />
      </div>
      <div class="param-row">
        <label for="tensionEmbellishProb">tensionEmbellishProb (0..1):</label>
        <input
          type="range"
          id="tensionEmbellishProb"
          min="0"
          max="1"
          step="0.1"
          value="0.2"
        />
      </div>
      <button id="updateMelodyBtn">Update Melody Pattern</button>
    </fieldset>

    <fieldset>
      <legend>Energy Manager Controls</legend>
      <p style="max-width: 600px">
        These quick switches alter “hype” (how busy/loud everything is) and
        “tension” (how dissonant or stable chord/melody structures become). This
        is a handy shortcut for performing live arrangement changes.
      </p>
      <div>
        <button data-hype="low">Set Hype: LOW</button>
        <button data-hype="medium">Set Hype: MEDIUM</button>
        <button data-hype="high">Set Hype: HIGH</button>
      </div>
      <div style="margin-top: 0.5rem">
        <button data-tension="none">Set Tension: NONE</button>
        <button data-tension="low">Set Tension: LOW</button>
        <button data-tension="mid">Set Tension: MID</button>
        <button data-tension="high">Set Tension: HIGH</button>
      </div>
    </fieldset>

    <p style="margin-top: 2rem; max-width: 700px">
      Try changing flavors, note durations, chord complexities, or hype/tension
      levels at any time. I'm continuing to build out new pattern ideas and ways
      of chaining them together. The goal is a simple browser-based setup that
      hooks to your hardware via Web MIDI, letting you spontaneously jam
      evolving tracks without a DAW.
    </p>

    <script type="module">
      import { createDefaultSystem } from "../src/system/create-default-system.js";
      import {
        LiveLoop,
        ColorfulChordSwellPattern,
        EvolvingLockedDrumPattern,
        PhraseContourMelody,
      } from "../src/index.js";

      (async function main() {
        const system = await createDefaultSystem();
        const {
          transport,
          energyManager,
          chordManager,
          globalContext,
          midiOutputs,
        } = system;

        globalContext.energyManager = energyManager;
        globalContext.chordManager = chordManager;
        chordManager.authorizeProvider("ColorfulChordSwellPattern");

        let chordPattern = new ColorfulChordSwellPattern({
          color: "warm",
          swellDuration: 16,
          overlap: 2,
          chordComplexity: 0.5,
        });
        const chordLoop = new LiveLoop(system.midiBus, {
          pattern: chordPattern,
          midiChannel: 8,
          name: "ColorfulChordLoop",
          role: "chordProvider",
          globalContext,
          deviceManager: system.deviceManager,
          midiOutputId: midiOutputs[0]?.id,
        });

        let drumPattern = new EvolvingLockedDrumPattern({
          patternLength: 16,
          drumIntensity: 0.5,
          flavor: "ambient",
          deviceDefinition: system.deviceManager.getDeviceForOutput(
            midiOutputs[0]?.id
          ),
        });
        const drumLoop = new LiveLoop(system.midiBus, {
          pattern: drumPattern,
          midiChannel: 1,
          name: "EvolvingDrums",
          role: "kickProvider",
          globalContext,
          deviceManager: system.deviceManager,
          midiOutputId: midiOutputs[0]?.id,
        });

        let melodyPattern = new PhraseContourMelody({
          phraseBars: 4,
          subSections: ["intro", "build", "peak", "resolve", "cadence"],
          stepsPerBar: 16,
          cadenceBeats: 2,
          melodicDensity: 0.7,
          baseVelocity: 90,
          tensionEmbellishProb: 0.2,
        });
        const melodyLoop = new LiveLoop(system.midiBus, {
          pattern: melodyPattern,
          midiChannel: 5,
          name: "PhraseMelody",
          role: null,
          globalContext,
          deviceManager: system.deviceManager,
          midiOutputId: midiOutputs[0]?.id,
        });

        transport.addLiveLoop(chordLoop);
        transport.addLiveLoop(drumLoop);
        transport.addLiveLoop(melodyLoop);

        console.log("System ready! Press play on external clock...");

        // Chord pattern controls
        const colorSelect = document.getElementById("colorSelect");
        const swellDurationInput = document.getElementById("swellDuration");
        const overlapInput = document.getElementById("overlap");
        const chordComplexityInput = document.getElementById("chordComplexity");
        document
          .getElementById("updateChordBtn")
          .addEventListener("click", () => {
            const newColor = colorSelect.value;
            const newSwell = parseInt(swellDurationInput.value, 10) || 16;
            const newOverlap = parseInt(overlapInput.value, 10) || 0;
            const newComplex = parseFloat(chordComplexityInput.value) || 0.5;

            chordPattern = new ColorfulChordSwellPattern({
              color: newColor,
              swellDuration: newSwell,
              overlap: newOverlap,
              chordComplexity: newComplex,
            });
            chordLoop.setPattern(chordPattern, true);
            console.log(
              "ChordPattern updated =>",
              newColor,
              newSwell,
              newOverlap,
              newComplex
            );
          });

        // Drum pattern controls
        const drumIntensityRange = document.getElementById("drumIntensity");
        const flavorSelect = document.getElementById("flavorSelect");
        document
          .getElementById("updateDrumsBtn")
          .addEventListener("click", () => {
            const newIntensity = parseFloat(drumIntensityRange.value) || 0.5;
            const newFlavor = flavorSelect.value;

            drumPattern = new EvolvingLockedDrumPattern({
              patternLength: 16,
              drumIntensity: newIntensity,
              flavor: newFlavor,
              deviceDefinition: system.deviceManager.getDeviceForOutput(
                midiOutputs[0]?.id
              ),
            });
            drumLoop.setPattern(drumPattern, true);

            console.log("DrumPattern updated =>", newIntensity, newFlavor);
          });

        // Melody pattern controls
        const phraseBarsEl = document.getElementById("phraseBars");
        const subSectionsEl = document.getElementById("subSections");
        const stepsPerBarEl = document.getElementById("stepsPerBar");
        const cadenceBeatsEl = document.getElementById("cadenceBeats");
        const melodicDensityEl = document.getElementById("melodicDensity");
        const baseVelocityEl = document.getElementById("baseVelocity");
        const tensionEmbellishEl = document.getElementById(
          "tensionEmbellishProb"
        );

        document
          .getElementById("updateMelodyBtn")
          .addEventListener("click", () => {
            const pb = parseInt(phraseBarsEl.value, 10) || 4;
            const subsArray = subSectionsEl.value
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s.length > 0);
            const spb = parseInt(stepsPerBarEl.value, 10) || 16;
            const cadBeats = parseFloat(cadenceBeatsEl.value) || 2;
            const density = parseFloat(melodicDensityEl.value) || 0.7;
            const baseVel = parseInt(baseVelocityEl.value, 10) || 90;
            const tProb = parseFloat(tensionEmbellishEl.value) || 0.2;

            melodyPattern = new PhraseContourMelody({
              phraseBars: pb,
              subSections: subsArray.length
                ? subsArray
                : ["build", "peak", "resolve"],
              stepsPerBar: spb,
              cadenceBeats: cadBeats,
              melodicDensity: density,
              baseVelocity: baseVel,
              tensionEmbellishProb: tProb,
            });
            melodyLoop.setPattern(melodyPattern, true);

            console.log(
              "MelodyPattern updated =>",
              "phraseBars:",
              pb,
              "subSections:",
              subsArray,
              "stepsPerBar:",
              spb,
              "cadenceBeats:",
              cadBeats,
              "density:",
              density,
              "baseVelocity:",
              baseVel,
              "tensionEmbellishProb:",
              tProb
            );
          });

        // Energy controls
        document.querySelectorAll("button[data-hype]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const newHype = btn.getAttribute("data-hype");
            energyManager.setHypeLevel(newHype);
            console.log("EnergyManager setHypeLevel:", newHype);
          });
        });
        document.querySelectorAll("button[data-tension]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const newTension = btn.getAttribute("data-tension");
            energyManager.setTensionLevel(newTension);
            console.log("EnergyManager setTensionLevel:", newTension);
          });
        });
      })();
    </script>
  </body>
</html>
